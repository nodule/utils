{
  "name": "utils",
  "description": "Utility components for ChiÏ‡",
  "version": "0.0.3",
  "repository": {
    "type": "git",
    "url": "https://github.com/nodule/utils.git"
  },
  "dependencies": {
    "inquiry": "0.x.x",
    "JSONPath": "0.x.x",
    "glob": "3.x.x",
    "xml2json": "0.x.x",
    "csv": "0.x.x",
    "iffi": "psichi/iffi",
    "json-path": "0.x.x",
    "xml2js": "0.x.x"
  },
  "nodes": [
    {
      "name": "log",
      "ns": "console",
      "description": "Console log",
      "phrases": {
        "active": "Logging to console"
      },
      "ports": {
        "input": {
          "msg": {
            "type": "any",
            "title": "Log message",
            "description": "Logs a message to the console",
            "required": true
          }
        },
        "output": {}
      },
      "fn": "console.log(input.msg)"
    },
    {
      "name": "cvs",
      "ns": "utils",
      "title": "CVS",
      "description": "NodeCSV Parser",
      "require": {
        "csv": "0.x.x"
      },
      "phrases": {
        "active": "Parsing CSV"
      },
      "ports": {
        "input": {
          "csv": {
            "type": "string",
            "title": "CSV",
            "description": "A Comma Seperated Values document",
            "required": true
          }
        },
        "output": {
          "data": {
            "type": "array",
            "title": "Output",
            "description": "An array of records"
          }
        }
      },
      "fn": "var un = {\n  chain: function(csv, cb) {\n    csv().\n    from.\n    string(input.csv, {} ).\n    to.\n    array(cb);\n  }\n};\n\noutput = [un, 'chain', input.csv];\n"
    },
    {
      "name": "glob",
      "ns": "fs",
      "title": "Glob",
      "description": "Match files using the patterns the shell uses, like stars and stuff.",
      "require": {
        "glob": "3.x.x"
      },
      "phrases": {
        "active": "Globbing with pattern: {{input.pattern}}"
      },
      "ports": {
        "input": {
          "match": {
            "type": "string",
            "title": "Pattern",
            "description": "Pattern to be matched",
            "required": true
          }
        },
        "output": {
          "error": {
            "type": "event",
            "title": "Error",
            "description": "Emitted when an unexpected error is encountered, or whenever any fs error occurs if `options.strict` is set."
          },
          "matches": {
            "type": "array",
            "title": "Matches",
            "description": "Filenames found matching the pattern"
          },
          "end": {
            "type": "event",
            "title": "End",
            "description": "When the matching is finished, this is emitted with all the matches found. If the `nonull` option is set, and no match was found, then the `matches` list contains the original pattern. The matches are sorted, unless the `nosort` flag is set."
          },
          "match": {
            "type": "event",
            "title": "Match",
            "description": "Every time a match is found, this is emitted with the matched."
          },
          "abort": {
            "type": "event",
            "title": "Abort",
            "description": "When `abort()` is called, this event is raised."
          }
        }
      },
      "fn": "output = function(cb) {\n\n  var mg = new glob.Glob(input.match, {}, function(err, matches) {\n\n    cb({\n      matches: matches\n    });\n\n    done();\n  \n  });\n\n  mg.on('match', function(match) {\n\n    cb({\n      match: match\n    });\n\n  });\n\n  mg.on('error', function(err) {\n\n    cb({\n      error: err \n    });\n\n  });\n\n  mg.on('abort', function() {\n\n    cb({\n      abort: null \n    });\n\n  });\n\n}\n"
    },
    {
      "name": "hello",
      "ns": "world",
      "description": "Hello World!",
      "phrases": {
        "active": "Hello World from phrases.active!"
      },
      "ports": {
        "input": {},
        "output": {
          "hello": {
            "type": "string",
            "title": "Hello World",
            "description": "Provides Hello to the world",
            "readonly": true
          }
        }
      },
      "fn": "output = { hello: 'Hello World!' }\n"
    },
    {
      "name": "if",
      "ns": "utils",
      "title": "IF",
      "description": "Accepts a value on one port and checks it against an if statement.",
      "require": {
        "iffi": "psichi/iffi"
      },
      "phrases": {
        "active": "Deciding IF"
      },
      "ports": {
        "input": {
          "value": {
            "type": "any",
            "title": "Value"
          },
          "if": {
            "type": "string",
            "title": "IF statement",
            "description": "Any if statement, the input is available as `in`. e.g. in.required === true, providing the input object has a property `required`, compilation failures will go to the output port."
          }
        },
        "output": {
          "error": {
            "type": "object",
            "title": "Error",
            "description": "Error"
          },
          "yes": {
            "type": "boolean",
            "title": "Yes"
          },
          "no": {
            "type": "boolean",
            "title": "No"
          }
        }
      },
      "fn": "try {\n  if(iffi(input['if'], { value: input.value })) {\n    output = { yes: true };\n  } else {\n    output = { no: true };\n  }\n} catch (e) {\n  output = { error: e };\n}\n"
    },
    {
      "name": "if2",
      "ns": "utils",
      "title": "IF2",
      "description": "Accepts values on two ports and checks it against an if statement.",
      "require": {
        "iffi": "psichi/iffi"
      },
      "phrases": {
        "active": "Deciding IF"
      },
      "ports": {
        "input": {
          "value1": {
            "type": "any",
            "title": "First Value"
          },
          "value2": {
            "type": "any",
            "title": "Second Value"
          },
          "if": {
            "type": "string",
            "title": "IF statement",
            "description": "Any if statement, the input is available as `in`. e.g. in.required === true, providing the input object has a property `required`, compilation failures will go to the output port."
          }
        },
        "output": {
          "error": {
            "type": "object",
            "title": "Error",
            "description": "Error"
          },
          "yes": {
            "type": "boolean",
            "title": "Yes"
          },
          "no": {
            "type": "boolean",
            "title": "No"
          }
        }
      },
      "fn": "try {\n  if(iffi(input['if'], {\n      'value1': input.value1,\n      'value2': input.value2\n    })) {\n    output = { yes: true };\n  } else {\n    output = { no: true };\n  }\n} catch (e) {\n  output = { error: e };\n}\n"
    },
    {
      "name": "if3",
      "ns": "utils",
      "title": "IF3",
      "description": "Accepts values on three ports and checks it against an if statement.",
      "require": {
        "iffi": "psichi/iffi"
      },
      "phrases": {
        "active": "Deciding IF"
      },
      "ports": {
        "input": {
          "value1": {
            "type": "any",
            "title": "First Value"
          },
          "value2": {
            "type": "any",
            "title": "Second Value"
          },
          "value3": {
            "type": "any",
            "title": "Third Value"
          },
          "if": {
            "type": "string",
            "title": "IF statement",
            "description": "Any if statement, the input is available as `in`. e.g. in.required === true, providing the input object has a property `required`, compilation failures will go to the output port."
          }
        },
        "output": {
          "error": {
            "type": "object",
            "title": "Error",
            "description": "Error"
          },
          "yes": {
            "type": "boolean",
            "title": "Yes"
          },
          "no": {
            "type": "boolean",
            "title": "No"
          }
        }
      },
      "fn": "try {\n  if(iffi(input['if'], {\n      'value1': input.value1,\n      'value2': input.value2,\n      'value3': input.value3\n    })) {\n    output = { yes: true };\n  } else {\n    output = { no: true };\n  }\n} catch (e) {\n  output = { error: e };\n}\n"
    },
    {
      "name": "interval",
      "ns": "util",
      "description": "Repeats the input",
      "phrases": {
        "active": "Repeating input every {{input.interval}} milliseconds."
      },
      "expose": [
        "setInterval"
      ],
      "ports": {
        "input": {
          "in": {
            "type": "any",
            "title": "Input",
            "description": "Input to be repeated",
            "readonly": true
          },
          "interval": {
            "type": "number",
            "title": "Interval",
            "description": "Interval in milliseconds",
            "format": "time",
            "required": true
          }
        },
        "output": {
          "out": {
            "type": "any",
            "title": "Output",
            "description": "Outputs the repeated input"
          }
        }
      },
      "fn": "var inter = {\n  val: function(to, cb) {\n   setInterval(function () { cb(input.in); }, to)\n  }\n}\noutput = [inter, 'val', input.interval]\n"
    },
    {
      "name": "merge",
      "ns": "object",
      "description": "Merges two object together, note: overlapping keys will overwrite",
      "phrases": {
        "active": "Merging objects together"
      },
      "ports": {
        "input": {
          "object1": {
            "type": "object",
            "title": "First Object",
            "required": true
          },
          "object2": {
            "type": "object",
            "title": "Second Object",
            "required": true
          }
        },
        "output": {
          "object": {
            "type": "object",
            "title": "Merged Object"
          }
        }
      },
      "fn": "var obj = {}\n\nobj[input.name1] = input.value1\nobj[input.name2] = input.value2\n\noutput = { object: obj }\n"
    },
    {
      "name": "mold",
      "ns": "object",
      "description": "Mold an object from two different inputs and name them",
      "phrases": {
        "active": "Molding object from {{input.name1}} & {{input.name2}}"
      },
      "ports": {
        "input": {
          "name1": {
            "type": "string",
            "title": "First value's name",
            "required": true
          },
          "value1": {
            "type": "any",
            "title": "First value",
            "required": true
          },
          "name2": {
            "type": "string",
            "title": "Second value's name",
            "required": true
          },
          "value2": {
            "type": "any",
            "title": "Second value",
            "required": true
          }
        },
        "output": {
          "object": {
            "type": "object",
            "title": "Object"
          }
        }
      },
      "fn": "var obj = {}\n\nobj[input.name1] = input.value1\nobj[input.name2] = input.value2\n\noutput = { object: obj }\n"
    },
    {
      "name": "wait",
      "ns": "util",
      "description": "Holds the input for a while",
      "phrases": {
        "active": "Holding input for {{input.timeout}} milliseconds."
      },
      "expose": [
        "setTimeout"
      ],
      "ports": {
        "input": {
          "in": {
            "type": "any",
            "title": "Input",
            "description": "Input to be delayed",
            "readonly": true
          },
          "timeout": {
            "type": "number",
            "title": "Timeout",
            "description": "Timeout in milliseconds",
            "format": "time"
          }
        },
        "output": {
          "out": {
            "type": "any",
            "title": "Output",
            "description": "Outputs the delayed input"
          }
        }
      },
      "fn": "var cmd = child_process.spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', function (data) {\n  console.log('stdout: ' + data);\n});\n\nls.stderr.on('data', function (data) {\n  console.log('stderr: ' + data);\n});\n\nls.on('close', function (code) {\n  console.log('child process exited with code ' + code);\n});\n\n\noutput = [slow, 'down', input.timeout]\n"
    },
    {
      "name": "true",
      "title": "true?",
      "ns": "conditional",
      "description": "Whether the input is true or false",
      "phrases": {
        "active": "Determining truth"
      },
      "ports": {
        "input": {
          "in": {
            "type": "boolean",
            "title": "A boolean"
          }
        },
        "output": {
          "yes": {
            "type": "boolean",
            "title": "Yes"
          },
          "no": {
            "type": "boolean",
            "title": "No"
          }
        }
      },
      "fn": "output = { yes: !!input.in, no: !input.in }\n"
    },
    {
      "name": "wait",
      "ns": "util",
      "description": "Holds the input for a while",
      "phrases": {
        "active": "Holding input for {{input.timeout}} milliseconds."
      },
      "expose": [
        "setTimeout"
      ],
      "ports": {
        "input": {
          "in": {
            "type": "any",
            "title": "Input",
            "description": "Input to be delayed",
            "readonly": true
          },
          "timeout": {
            "type": "number",
            "title": "Timeout",
            "description": "Timeout in milliseconds",
            "format": "time"
          }
        },
        "output": {
          "out": {
            "type": "any",
            "title": "Output",
            "description": "Outputs the delayed input"
          }
        }
      },
      "fn": "var slow = {\n  down: function(to, cb) {\n   setTimeout(function () { cb(input.in); }, to)\n  }\n}\noutput = [slow, 'down', input.timeout]\n"
    },
    {
      "name": "wait",
      "ns": "util",
      "description": "Holds the input for a while",
      "phrases": {
        "active": "Holding input for {{input.timeout}} milliseconds."
      },
      "expose": [
        "setTimeout"
      ],
      "ports": {
        "input": {
          "in": {
            "type": "any",
            "title": "Input",
            "description": "Input to be delayed",
            "readonly": true
          },
          "timeout": {
            "type": "number",
            "title": "Timeout",
            "description": "Timeout in milliseconds",
            "format": "time"
          }
        },
        "output": {
          "out": {
            "type": "any",
            "title": "Output",
            "description": "Outputs the delayed input"
          }
        }
      },
      "fn": "var slow = {\n  down: function(to, cb) {\n   setTimeout(function () { cb(input.in); }, to)\n  }\n}\noutput = [slow, 'down', input.timeout]\n"
    },
    {
      "name": "xml2js",
      "ns": "utils",
      "description": "Simple XML to JavaScript object converter",
      "require": {
        "xml2js": "0.x.x"
      },
      "phrases": {
        "active": "Converting XML to Object"
      },
      "ports": {
        "input": {
          "xml": {
            "type": "string",
            "format": "xml",
            "title": "XML"
          }
        },
        "output": {
          "err": {
            "type": "object",
            "title": "Error Object"
          },
          "result": {
            "type": "object"
          }
        }
      },
      "fn": "output = [xml2js, 'parseString', input.xml]\n"
    }
  ],
  "twigs": []
}