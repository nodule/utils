{
  "name": "inquiry",
  "description": "A parameterized JSON path language for Node.js and the browser.",
  "version": "0.0.2",
  "homepage": "http://bigeasy.github.com/inquiry",
  "repository": {
    "type": "git",
    "url": "http://github.com/bigeasy/inquiry.git"
  },
  "author": {
    "name": "Alan Gutierrez",
    "email": "alan@prettyrobots.com",
    "url": "http://twitter.com/bigeasy"
  },
  "url": "http://bigeasy.github.com/inquiry",
  "keywords": [
    "json",
    "inquiry",
    "jsonpath",
    "xpath",
    "selectors",
    "query"
  ],
  "contributors": [],
  "dependencies": {},
  "devDependencies": {
    "proof": "0.0.30",
    "uglify-js": "~1.3"
  },
  "scripts": {
    "test": "proof platform win32 && proof test t/*/*.t.js || t/test"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/bigeasy/inquiry/raw/master/LICENSE"
    }
  ],
  "readme": "<a href=\"http://www.flickr.com/photos/pjern/5878353945/\" title=\"Information Please by pjern, on Flickr\"><img src=\"http://farm6.staticflickr.com/5234/5878353945_0c07d304fd_b.jpg\" width=\"850\" height=\"566\" alt=\"Information Please\"></a>\n\n# Inqury [![Build Status](https://secure.travis-ci.org/bigeasy/inquiry.png?branch=master)](http://travis-ci.org/bigeasy/inquiry) [![Coverage Status](https://coveralls.io/repos/bigeasy/inquiry/badge.png?branch=master)](https://coveralls.io/r/bigeasy/inquiry) [![NPM version](https://badge.fury.io/js/inquiry.png)](http://badge.fury.io/js/inquiry)\n\nA micro-JavaScript JSON path language for Node.js and the browser.\n\n```javascript\nvar $q = require(\"inqury\"), hickory, object =\n  { presidents:\n  [ { firstName: \"George\", lastName:\"Washington\" }\n  , { firstName: \"John\", lastName:\"Adams\" }\n  , { firstName: \"Thomas\", lastName:\"Jefferson\" }\n  , { firstName: \"James\", lastName:\"Madison\" }\n  , { firstName: \"James\", lastName:\"Monroe\" }\n  , { firstName: \"John\", lastName:\"Quincy Adams\" }\n  , { firstName: \"Andrew\", lastName:\"Jackson\" }\n  , { firstName: \"Martin\", lastName:\"Van Buren\" }\n  , { firstName: \"William\", lastName:\"Henry Harrison\" }\n  , { firstName: \"John\", lastName:\"Tyler\" }\n  , { firstName: \"James\", middleInitial:\"K\", lastName:\"Polk\" }\n  , { firstName: \"Zachary\", lastName:\"Taylor\" }\n  , { firstName: \"Millard\", lastName:\"Fillmore\" }\n  , { firstName: \"Franklin\", lastName:\"Pierce\" }\n  , { firstName: \"James\", lastName:\"Buchanan\" }\n  , { firstName: \"Abraham\", lastName:\"Lincoln\" }\n  ]};\n\nhickory = $q('/p*{$.lastName == $1}')(object, \"Jackson\").pop();\n\nconsole.log(\"Found: \" hickory.firstName + \" \" + hickory.lastName);\n```\n\nInquiry is a **tiny** library that can perform **complex** searches on\ncomplicated **nested** collections JavaScript object graphs.\n\nInquiry is a **functional** library that builds a reusable JavaScript function\nfrom a path expression.\n\nThe path expression language supports **parameters**, **expressions**, and\n**sub-queries**.\n\n## Paths\n\nPaths are forward slash delimited. The path part begins right after the slash\nand ends at the first unescaped forward slash, open square bracket, open curly\nbrace; `/`, `` [ ``, `{`.\n\n```javascript\nvar abe = $q('/presidents/15/firstName')(object).pop();\n```\n\nThe initial slash is optional. Paths always begin at the root object.\n\n```javascript\nvar abe = $q('presidents/15/firstName')(object).pop();\n```\n\nThis allows you to put most things in your paths, you only need to escape the\naforementioned terminators, a period `.` if it appears at the start of the path\npart, the asterisk `` * ``, and the percent sign `%` which I'm reserving for a\nJSON pointer implementation.\n\n```javascript\nvar object = { \"don't you love punctuation?\": { \"yes!\": 1, \"no\": 0 } };\nvar yes = $q(\"don't you love punctuation?/yes!\")(object).pop();\n```\n\nEscape using a backtick `` ` ``. We use a backtick and not a backslash, because\nthen you'd have to double those backslashes up in a JavaScript string, which\nwould lead to [leaning toothpick\nsyndrome](http://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).\n\n```javascript\nvar object = { \"forward/slash\": { \"curly{brace\": 1, \"square[bracket\": 2 } };\nvar a = $q('forward`/slash/curly`{brace')(object).pop();\n```\n\nPaths can have a dot `.` for self refernece and two dots `..` to reference the\nparent just like file paths. Below is a silly example. Parent paths are more\nuseful in predicates and sub-queries.\n\n```javascript\nvar abe = $q('presidents/14/../15/./firstName')(object).pop();\n```\n\n## Invocation\n\n**Now that you have a notion of what a path looks like, let's talk about\ninvocation.**\n\nInquiry is a function compiler. Inquiry compiles a path expression into a\nJavaScript function.\n\n```javascript\nvar $q = require('inquiry');\n\nvar firstNameByLastName = $q('presidents{$.lastName = $1}/firstName');\n\nok(byLastName(object, 'Lincoln').pop() == 'Abraham');\nok(firstNames(object, 'Washington').pop() == 'George');\n```\n\nInquiry is all functional like that. You can then call that JavaScript function\nhowever many times you'd like. You can pass the function to another function as\na parameter.\n\nHowever, the Inquiry compiler is quick enough that you can simply compile and\ninvoke in a one liner.\n\n```javascript\nvar $q = require('inquiry');\n\nvar abe = $q('presidents{$.lastName == $1}/firstName')(object, 'Lincoln');\nok(abe == 'Abraham');\n```\n\n## One Wildcard Per Property\n\nIn a path, you're allowed one and only one wildcard represented by a star\n`` * ``.\n\nWildcards help to make verbose queries terse.\n\n```javascript\nvar instances = $q('reservationSet/reservation/instanceSet/instance')(object);\n```\n\nA few wildcards and the path is under control, but still readable.\n\n```javascript\nvar instances = $q('r*Set/reservation/i*Set/instance')(object);\n```\n\nYou're only allowed one wildcard per property name. Wildcards are used to tame\nverbosity, not for pattern matching. There is no good way to pattern match\nagainst property names in inquiry. You're expected to know the structure of the\nJSON you're querying.\n\n## JSON Pointer\n\nYou can also [JSON\npointer](http://tools.ietf.org/html/draft-pbryan-zyp-json-pointer-02) which is\nsimply URL encoded path parts.\n\n```javascript\nvar object = { \"@#$%^&\": { \">\": 0, \"%3E\": 1 } };\nequal($q(\"%40%23%24%25%5E%26/%3E\")(object).pop(), 0, 'encoded');\nequal($q(\"%40%23%24%25%5E%26/`%3E\")(object).pop(), 1, 'escaped encoding');\n```\n\nI imagine this might be helpful if you want to add paths to URLs, but I've not\nfound a use case in the wild. If you do find, one [drop me a\nline](https://github.com/bigeasy/inquiry/issues/12).\n\n## Arrays\n\nArrays are a special case. When we visit an array, if the path step is all\ndigits, we simply use that path step as an index.\n\n```javascript\nok( $q('presidents/15')(object).pop().lastName == 'Lincoln' );\n```\n\nIf it is not all digits, we assume that we want to gather the property for every\nelement in the array. This gathers values into the result array.\n\n```javascript\nok( $q('presidents/lastName')(object)[15] == 'Lincoln' );\n```\n\nYou can, of course, invoke Inquiry against an array directly. The path will be\napplied to each element in the array.\n\n```javascript\nok( $q('lastName')(object.presidents).shift() == 'Washington' );\nok( $q('15/lastName')(object.presidents).shift() == 'Lincoln' );\n```\n\nNote that we **do not** use brackets `[]` to indicate an array element. Brackets\nare used to define sub-query predicates.\n\n## JavaScript Predicates\n\nCurly braces indicate JavaScript\n[predicates](http://stackoverflow.com/questions/3230944/what-does-predicate-mean-in-the-context-of-computer-science).\nA JavaScript predicate is simply a JavaScript expression that is compiled to a\nfunction that returns a boolean. If the JavaScript expression that evaluates to\n`true`, the path is included in the result set.\n\nEach step in the path can include a single JavaScript predicate.\n\nA predicate expression references the current object using the varaible `$`.\n\n```javascript\nvar abe = $q('{$.lastName == \"Lincoln\"}')(object.presidents[15]).pop();\n```\n\nWhen a predicate expression is used with an array, it is tested against all the\nmembers of the array.\n\n```javascript\nvar abe = $q('presidents{$.lastName == \"Lincoln\"}')(object).pop();\n```\n\nA predicate expression references arguments using the special variables `$1`\nthrough `$256`, each variable representing an argument by position.\n\n```javascript\nvar abe = $q('presidents{$.lastName == $1}')(object, 'Lincoln').pop();\n```\n\nYou can negate a JavaScript predicate using an exclamation point `!`.\n\n```javascript\nvar abe = $q('presidents!{$.lastName != \"Lincoln\"}')(object).pop();\n```\n\nA predicate expression can reference the index of an array using the special\nvariable `$i`.\n\n```javascript\nvar abe = $q('presidents{$i == 15}')(object).pop();\n```\n\nWhen you invoke Inquiry directly against an array, you apply a JavaScript\npredicate by defining it immediately.\n\n```javascript\nvar abe = $q('{$i == 15}')(object.presidents).pop();\n```\n\n## Sub-Query Predicates\n\nSquare brackets define sub-query\n[predicates](http://stackoverflow.com/questions/3230944/what-does-predicate-mean-in-the-context-of-computer-science).\nA sub-query predicate is a query that is performed in the context of each\nobject that matches the path, current object or against each object in an array\nif the object that matches the path is an array. If the sub-query returns any\nobjects at all, the predicate is considered true and the object matches.\n\n```javascript\nvar datacenter = {\n  instances: [{\n    id: 1,\n    running: true,\n    tags: [{\n      key: 'name', value: 'server'\n    }, {\n      key: 'arch', value: 'i386'\n    }]\n  }, {\n    id: 2,\n    tags: [{\n      key: 'name', value: 'balancer'\n    }, {\n      key: 'arch', value: 'x86_64'\n    }]\n  }, {\n    id: 3,\n    running: true,\n    tags: []\n  }]\n};\nvar tagged = $q('instances[tags/key]')(datacenter);\nok(tagged.length == 2);\n```\n\nIn the above, for each `instance` the sub-query looks for `tags/key`. This\nmatches any of the `instance` objects who's `tags` array has an object with a\n`key` property, regardless of value.\n\nYou can nest JavaScript predicates inside sub-query predicates.\n\n```javascript\nvar server = $q('instances[tags{$.key == \"name\" && $.value == $1}]')(datacenter, 'server').pop();\n```\n\nIn the above, for each `instance` object we look in the `tags` array for a\n`name` property with the value \"server.\"\n\nYou can use parent operator `..` to compare against a parent in a sub-query\npredicate, or multiple parent operators `../..` to compare against other\nancestors. It's just like `..` in file paths.\n\n***However***, Inquiry will dive into an array so, so to get back out of an\narray, you need to use `../..`. Use `..` to go to the other array elements and\n`../..` to go up to the object that contains the array.\n\nIf you go up beyond the root, bad things happen. Don't do it.\n\nThe following will get the tags of all instances that have a `running` property.\n\n```javascript\nvar tags = $q('instances/tags[../../running]')(instances);\nok(tags.length == 2);\n```\n\nGranted, the above is not terribly useful since it returns the tags, but not the\ninstance itself, so the tags have no context. Really useful queries of parents\nand siblings require capturing the properties of the object at the current\npath with the properties of a parent or sibling.\n\nA sub-query predicate can reference the context of query that invoked it using\nthe variable `$$`. This variable references the context object of the outer\nquery at when the sub-query predicate was invoked. The variable `$$i` contains\nthe index of the context object of the outer query when the sub-query predicate\nwas invoked.\n\nHere we look for any president that shares a first name with any another president.\n\n```javascript\nvar dup = $q('presidents[..{$.firstName == $$.firstName && $i != $$i}]')(object);\nok(dup.length == 7);\nok(dup[dup.length - 1].firstName = 'James');\n```\n\nWe compared the first name of the outer president with the first names of all the other\npresidents, excluding the outer president himself by his index.\n\nHere we look for a president that does not share a first name with any other\npresident.\n\n```javascript\nvar uniq = $q('presidents![..{$.firstName == $$.firstName && $i != $$i}]')(object);\nok(uniq.length == 9);\nok(uniq[uniq.length - 1].firstName == 'Abraham');\n```\n\nIf you're wondering, yes, you can nest deeper than a single sub-query; a `$$$`\nvariable and a `$$$i` variable will be created.\n\nWhen you invoke Inquiry directly against an array, you apply a JavaScript\npredicate by defining it immediately.\n\n```javascript\nvar uniq = $q('![..{$.firstName == $$.firstName && $i != $$i}]')(object.presidents);\nok(uniq.length == 9);\nok(uniq[uniq.length - 1].firstName == 'Abraham');\n```\n\n## Errors\n\nInquiry is a minimal path language for maximum effect. Error reporting is\nminimal, too. If you give it a bad pattern, it will raise an exception, but it\ndoesn't offer much in the way of suggestions to fix the pattern. Diagnostics of\nthat sort would be expensive.\n\nMost of your patterns will be simple and obvious, so you're not going to want to\npay for the complexity of details diagnostics. If you're having trouble with a\ncomplicated pattern, try building it incrementally, adding the bits and pieces\nto the pattern so you'll see when it breaks.\n\n## Change Log\n\nChanges for each release.\n\n### Version 0.0.2\n\nThu Jun 20 21:35:33 UTC 2013\n\n * Note that brackets are not for arrays. #32.\n * Add invocation against arrays to `README.md`. #42.\n * Reduced to under 1k minified and gzipped.\n * Complete test of all `README.md` examples. #41.\n * Replace parameters with doubled dollar signs. #43.\n * Test the `README.md` examples. #41.\n * Negate predicates. #36.\n * Implement sub-query predicate parameters. #40.\n * Implement multiple predicates. #26.\n * Test searching against nested arrays. #25.\n * Test parent operator against an array. #33.\n * Test that paths can continue past predicates. #35.\n * Test coverage of AMD bandages. #37.\n * Rewrite sub-query documentation. #28.\n * Test coverage with Istanbul and Coveralls.\n * Use `in` operator instead of comparing to `undefined`. #30.\n * Apply self operator `.` to arrays. #31.\n * Implement JSON pointer.\n * Fix select `null` and zero. #29.\n * Escape special characters. #20.\n * Implement parent `..` operator. #27.\n * Implement sub-queries. #15.\n * Apply wildcards after an array. #22.\n * Update `t/sizes` minification report for Bash 3.0. #23.\n * Added `.js` suffix to test file names. #24.\n * Apply predicate to every member of array. #21.\n\n### Version 0.0.1\n\nReleased: Sun Jul 22 19:47:59 UTC 2012.\n\n * Path passes through all elements in array. #18.\n * Select array element by index. #17.\n * Implement arguments. #11.\n * Select by wildcard. #10.\n * Build on Windows. #9.\n * Build on Travis CI. #5.\n * Upgrade to Proof 0.0.15. #8. #6.\n * Convert to a function compiler. #7.\n * Return an array always. #3.\n\n### Version 0.0.0\n\nReleased: Thu Jun 28 15:16:23 UTC 2012.\n\n * Select property by name. #1.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bigeasy/inquiry/issues"
  },
  "_id": "inquiry@0.0.2",
  "_from": "inquiry@latest"
}
